;JUMPS
.MODEL  huge
draw_row Macro x
    Local l1
;draws a line in row x from col 10 to col 300
    MOV AH, 0CH
    MOV AL, 2
    MOV CX, 10
    MOV DX, x
L1: INT 10h
    INC CX
    CMP CX, 310
    JLE L1
EndM

draw_col Macro y
    Local l2
;draws a line col y from row 10 to row 189
    MOV AH, 0CH
    MOV AL, 2
    MOV CX, y
    MOV DX, 10
L2: INT 10h
    INC DX
    CMP DX, 190
    JL L2
EndM 


.Stack 120h
.Data
new_timer_vec   dw  ?,?
old_timer_vec   dw  ?,?
NEW_KEY_VEC DW  ?,?
OLD_KEY_VEC DW  ?,?
SCAN_CODE   DB  0
KEY_FLAG    DB  0
timer_flag  db  0
;Gun_coord
GUN_TOP     DW  45
GUN_BOTTOM  DW  60
GUN_LEFT    DW  20
GUN_RIGHT   DW  20

;score
SHOW_SCORE DB 'SCORE: $'
string db 'BALLOON SHOOTER$'
NEW db 'PRESS n FOR NEW GAME$'
CONT db 'PRESS p TO CONTINUE$'
GAME_OVER DB 'GAME OVER!!!!$'
YOUR_SCORE DB 'YOUR SCORE IS $'
again_restart db 'PRESS r TO RESTART GAME$'
ESC_SAVE1 DB 'PRESS esc TO SAVE AND$'
ESC_SAVE2 DB 'EXIT WHILE PLAYING$'
REMOVE DB '                           $' ;for removing the press key type strings
SCORE1 db 0                             ;showing unit digit
SCORE2 db 0                             ;showing tenth digit

;balloon_coord
balloon_x dw 1 DUP(200,100,240,130,270) 
balloon_y dw 1 DUP(157,157,157,157,157)
total_balloon dw 5       ;total balloon number
total_balloon2 dw 10     ;total balloon number * 2 (multi by 2)

interval dw 10          ;Time difference of new balloon shoot
timer dw 0              ;current time difference after last new balloon shoot
game_timer dw 0         ;current time difference of last game started
game_time dw 1000       ;Total time of ending the game

;bullet co-ordinate
bullet_x dw 4 DUP(20,20,20,20,20)
bullet_y dw 4 DUP(0,0,0,0,0)
total_bullet dw 10      ;total bullet number
total_bullet2 dw 20     ;total bullet number * 2 (multi by 2)

;temporary
count dw 0              ;varible for loop counting
count1 dw 0             ;varible for loop counting

;velocity of balloon
vel_y dw  2


;File for saving the game progress
FILE DB 'gamesave.txt',0
HANDLE DW ? 
BUFFER DB 512 DUP (0)  
OPENERR db 0DH,0AH, 'OPEN ERROR $'
WRITERR DB 0DH,0AH,'WRITE ERROR $' 

;scan codes generated by key board interrupt
;Scan codes are not ascii & can be found on internet 
UP_ARROW = 72
DOWN_ARROW = 80
LEFT_ARROW = 75
RIGHT_ARROW = 77
ESC_KEY = 1
P_KEY = 25
N_KEY = 49
R_KEY = 19


.CODE

setup_int Proc
; save old vector and set up new vector
; input: al = interrupt number
;    di = address of buffer for old vector
;    si = address of buffer containing new vector
; save old interrupt vector
    MOV AH, 35h ; get vector
    INT 21h
    MOV [DI], BX    ; save offset
    MOV [DI+2], ES  ; save segment
; setup new vector
    MOV DX, [SI]    ; dx has offset
    PUSH DS     ; save ds
    MOV DS, [SI+2]  ; ds has the segment number
    MOV AH, 25h ; set vector
    INT 21h
    POP DS
    RET
setup_int EndP

;will be auto called when 1 tick is happened  
timer_tick Proc
    PUSH DS
    PUSH AX
    
    MOV AX, Seg timer_flag
    MOV DS, AX
    MOV timer_flag, 1     
    inc timer        ;increment current time for balloon shooting
    inc game_timer   ;increment current running time of the game
    
    POP AX
    POP DS
    
    IRET
timer_tick EndP
 

KEYBOARD_INT    PROC
;keyboard interrupt routine
;save registers
    PUSH    DS
    PUSH    AX
;set up DS
    MOV AX,SEG SCAN_CODE
    MOV DS,AX
;input scan code
    IN  AL,60H      ;read scan code
    PUSH    AX      ;save it
    IN  AL,61H      ;control port
    MOV AH,AL       ;save in AH
    OR  AL,80H      ;set bit for keyboard
    OUT 61H,AL      ;write back
    XCHG    AH,AL       ;get back control value
    OUT 61H,AL      ;reset control port
    POP AX      ;recover scan code
    MOV AH,AL       ;save scan code in AH
    TEST    AL,80H      ;test for break code
    JNE KEY_0       ;yes, clear flags, goto KEY_0
;make code
    MOV SCAN_CODE,AL    ;save in variable
    MOV KEY_FLAG,1  ;set key flag
KEY_0:  MOV AL,20H      ;reset interrupt
    OUT 20H,AL
;restore registers
    POP AX
    POP DS
    IRET
KEYBOARD_INT    ENDP        ;end KEYBOARD routine
    

;sound generating procedure
BEEP    PROC
;generate beeGUNg sound
    PUSH    CX      ;save CX
;initialize timer
    MOV AL,0B6H     ;specify mode of operation
    OUT 43H,AL      ;write to port 43h
;load count
    MOV AX,1193     ;count for 1000 Hz
    OUT 42H,AL      ;low byte
    MOV AL,AH       ;high byte
    OUT 42H,AL
;activate speaker
    IN  AL,61H      ;read control port
    MOV AH,AL       ;save value in AH
    OR  AL,11B      ;set control bits
    OUT 61H,AL      ;activate speaker
;500 ms delay loop
    MOV CX,9        ;do 9 times
B_1:    CMP TIMER_FLAG,1    ;check timer flag
    JNE B_1     ;not set, loop back
    MOV TIMER_FLAG,0    ;flag set, clear it
    LOOP    B_1     ;repeat for next tick
;turn off tone
    MOV AL,AH       ;return old control value to AL
    OUT 61H,AL      ;restore control value
;
    POP CX      ;restore CX
    RET
BEEP    ENDP

set_display_mode Proc
; sets display mode and draws boundary
    MOV AH, 0
    MOV AL, 04h; 320x200 4 color
    INT 10h
; select palette    
    MOV AH, 0BH
    MOV BH, 1
    MOV BL, 0
    INT 10h
; set bgd color
    MOV BH, 0
    MOV BL, 3; cyan
    INT 10h
    
;intro for press keys
    mov ah,2
    mov bh,0
    mov dx,080ch
    int 10h
    
    mov ah,9
    lea dx,string
    int 21h
    
    
    MOV AH,2
    MOV BH,0
    MOV DX,0C0AH
    INT 10H
    
    MOV AH,9
    LEA DX,NEW
    INT 21H
    
    MOV AH,2
    MOV BH,0
    MOV DX,0E0AH
    INT 10H
    
    MOV AH,9
    LEA DX,ESC_SAVE1
    INT 21H
    
    MOV AH,2
    MOV BH,0
    MOV DX,0F0AH
    INT 10H
    
    MOV AH,9
    LEA DX,ESC_SAVE2
    INT 21H
    
    MOV AH,2
    MOV BH,0
    MOV DX,110AH
    INT 10H
    
    MOV AH,9
    LEA DX,CONT
    INT 21H
    
    MOV AH,2
    MOV BH,0
    MOV DH,0
    MOV DL,38
    INT 10H
;Roll numbers showing in reverse order
    MOV AH, 9
    MOV AL,'9'
    MOV BL,2
    MOV CX,1
    INT 10H
 
          
    MOV AH,2
    DEC DL
    INT 10H
    
    MOV AH, 9
    MOV AL,'7'
    MOV BL,2
    MOV CX,1
    INT 10H
 
          
    MOV AH,2
    DEC DL
    INT 10H

    MOV AH, 9
    MOV AL,'&'
    MOV BL,2
    MOV CX,1
    INT 10H
 
          
    MOV AH,2
    DEC DL
    INT 10H
    
    
    MOV AH, 9
    MOV AL,'1'
    MOV BL,2
    MOV CX,1
    INT 10H
 
          
    MOV AH,2
    DEC DL
    INT 10H
         
    MOV AH, 9
    MOV AL,'6'
    INT 10H

    MOV AH,2
    DEC DL
    INT 10H
         
    MOV AH, 9
    MOV AL,'0'
    INT 10H

    MOV AH,2
    DEC DL
    INT 10H
         
    MOV AH, 9
    MOV AL,'5'
    INT 10H

    MOV AH,2
    DEC DL
    INT 10H
         
    MOV AH, 9
    MOV AL,'0'
    INT 10H

    MOV AH,2
    DEC DL
    INT 10H
         
    MOV AH, 9
    MOV AL,'4'
    INT 10H

    MOV AH,2
    DEC DL
    INT 10H
         
    MOV AH, 9
    MOV AL,'1'
    INT 10H
    
; draw boundary
    draw_row 10
    draw_row 190
    draw_col 10
    draw_col 310
    
    RET
set_display_mode EndP


DRAW_GUN    PROC

    PUSH    CX
    PUSH    DX

    MOV AH,0CH      ;write pixel function
    MOV CX,GUN_LEFT  
    MOV DX,GUN_TOP  ;top row
DP1:    
    INT 10H
    INC DX      ;next row
    CMP DX,GUN_BOTTOM ;done?
    JLE DP1     ;no, repeat

    POP DX
    POP CX
    RET
DRAW_GUN    ENDP        
    

MOVE_GUN    PROC
    MOV BX,AX       ;copy to BX
    CMP AX,-2   
    JE  UP          
    CMP AX,3    
    JE  DOWN        

UP: 
    CMP GUN_TOP,12  ;at top?
    JLE DONE1       ;yes, cannot move
    JMP UPDATE
    
DOWN:   
    CMP GUN_BOTTOM,188  ;at bottom?
    JGE DONE1       ;yes, cannot move
    JMP UPDATE

UPDATE: 

    MOV AL,0 
    CALL    DRAW_GUN

    CMP BX,-2
    JE UD
    CMP BX,3
    JE UD
UD: 
    ADD GUN_TOP,BX
    ADD GUN_BOTTOM,BX
    MOV AL,2     
    CALL    DRAW_GUN

DONE1:  
    
    RET
    
MOVE_GUN    ENDP

;Updates the score while playing
update_score Proc
    push ax
    push dx
    inc score1
    
    MOV AH,2
    MOV BH,0
    MOV DX,0000H
    INT 10H
    
    MOV AH,9
    LEA DX,SHOW_SCORE
    INT 21H
    
    CMP SCORE1,9
    JG INC_SCORE2
    JMP PRINT_SCORE
    
    INC_SCORE2:
    ;XOR AL,AL
    MOV SCORE1,0
    INC SCORE2
    
    PRINT_SCORE:
    MOV AH,2
    MOV DL,SCORE2
    ADD DL,'0'
    INT 21H
    
    MOV DL,SCORE1
    ADD DL,'0'
    INT 21H
    
    mov dl,8
    int 21h
    MOV DL,8
    INT 21H
    
    pop dx
    pop ax
    ret
update_score endP
 
;Draws the ballon if al=3 and removes the balloon if al=0
;cx & dx contains co-ordi of balloon top point
display_balloon Proc

    PUSH CX
    PUSH DX
    PUSH AX
    
    MOV AH, 0CH ; write pixel
    PUSH BX
    MOV BX,9
    
    INT 10h
    b1:
    INC CX
    INC DX
    INT 10h
    dec bx
    cmp bx,0
    jne b1
    mov bx,9
    
    b2:
    DEC CX
    INC DX
    INT 10h
    dec bx
    cmp bx,0
    jne b2
    mov bx,9
    
    b3:
    DEC CX
    DEC DX
    INT 10h
    dec bx
    cmp bx,0
    jne b3
    mov bx,9
    
    b4:
    INC CX
    DEC DX
    INT 10h
    dec bx
    cmp bx,0
    jne b4
    pop bx
    
    pop ax
    pop DX
    Pop cx
    
    RET 
display_balloon EndP

;check whether the balloon crossed the upper line where y=12   
check_balloon Proc

    cmp dx,12
    jle erase_balloon       ;crossed the line so remove the balloon
    ret

erase_balloon:
    mov al,0
    call display_balloon    
    mov dx,157              ;reset the y cordinate so that it can used to shoot as new balloon
    ret

check_balloon EndP

;Removes the balloons when game time is over
remove_balloon Proc
    push cx
    push dx
    push ax
    LEA si,balloon_x
    LEA di,balloon_y
    mov cx,0
    nonempty_balloon2:
    cmp word ptr[di],157
    je empty7
    push cx
    
    mov cx,[si]
    mov dx,[di]

    MOV AL, 0
    CALL display_balloon
    
    pop cx
    empty7:
    inc cx
    add si,2
    add di,2
    cmp cx,total_balloon
    je fill_balloon3
    jmp nonempty_balloon2
    fill_balloon3:
    
   
    pop ax
    pop dx
    pop cx
    
    RET 
remove_balloon EndP

;Moves the balloons if they are shooted and checks for boundary cross
move_balloon Proc
    push cx
    push dx
    push ax
    LEA si,balloon_x
    LEA di,balloon_y
    mov cx,0
    nonempty_balloon:
    cmp word ptr[di],157        ;check if the ballon is on moving or not
    je empty4
    push cx
    
    mov cx,[si]
    mov dx,[di]
    call check_balloon          ;check if the ballon crossed the boundary
    
    cmp dx,157                  ;the ballon has crossed the boundary 
    je saveonlyballoon          ; so only saved the changed value as it has been removed earlier
    
    MOV AL, 0
    CALL display_balloon        ;remove the balloon from previous position
   
    sub dx, vel_y               ;shift the y co-ordi to upper side
        
    MOV AL, 3
    CALL display_balloon        ;draw the balloon in new position
    
    saveonlyballoon:    
    MOV [di],dx                 ;save only changed y co-ordi as x will not be affected anyway
    
    pop cx
    empty4:
    inc cx
    add si,2
    add di,2
    cmp cx,total_balloon
    je fill_balloon1            
    jmp nonempty_balloon        ;check for every balloon
    fill_balloon1:
    
    pop ax
    pop dx
    pop cx
    
    RET 
move_balloon EndP

;Draws the bullet if al=3 and removes the bullet if al=0
;cx & dx contains co-ordi of bullet top point      
display_bullet Proc

    PUSH CX
    PUSH DX
    PUSH AX    

    MOV AH, 0CH ; write pixel
    INT 10h
    INC CX      ; pixel on next col
    INT 10h
    INC DX      ; down 1 row
    INT 10h
    DEC CX      ; prev col
    INT 10h
    DEC DX      ; restore dx
    
    POP AX
    POP DX
    POP CX
    RET 
display_bullet EndP

;Check if the bullet is crossed the line of y=305  or in the middle of any balloon
check_bullet Proc
    cmp cx,305
    jne bullet1
    MOV AL, 0
    CALL display_bullet
    mov cx,20
    ret
bullet1:                    ;check inside balloon
    LEA si,balloon_x
    LEA di,balloon_y
    mov count1,0 
    nonempty_balloon1:      
    cmp [di],157            ;check if the balloon is shooted, if not skip
    je empty5
    
    cmp cx,[si]             ;check if their x co-ordi are same
    je bullet2
    jmp empty5
    bullet2:
    mov bx,[di]             
    cmp bx,dx               ;check if balloon-s top point-s y co-ordi is less then the y co-ordi of bullet
    jle bullet3
    jmp empty5
    bullet3:
    add bx,18
    cmp bx,dx               ;check if balloon-s bottom point-s y co-ordi is greater then the y co-ordi of bullet
    jge bullet4
    jmp empty5
    bullet4:
    ;call beep               ;generates the sound and slows the game
    call update_score       ;update the score
    
    MOV AL, 0
    CALL display_bullet     ;remnoves the bullet
    ;mov bullet_flag,0
    
    mov cx,[si]
    mov dx,[di]

    MOV AL, 0
    CALL display_balloon    ;remnoves the balloon
    
    mov cx,20               ;reset the x cordinate so that it can used to shoot as new bullet
    mov [di],157            ;reset the y cordinate so that it can used to shoot as new balloon
    
    jmp fill_balloon2       ;shooted now exit the loop
    empty5:
    inc count1              
    
    add si,2
    add di,2
    mov bx,count1
    cmp bx,total_balloon
    je fill_balloon2
    jmp nonempty_balloon1
    fill_balloon2:
   
    ret
check_bullet endp
;Removes the bullet when game time is over
remove_bullet Proc 
    PUSH CX
    PUSH DX
    PUSH AX
    LEA si,bullet_x
    LEA di,bullet_y
    mov count,0
    nonempty_bullet2:
    cmp word ptr[si],20
    je empty6
    
    mov cx,[si]
    mov dx,[di]

    MOV AL, 0
    CALL display_bullet 
    
    empty6:
    inc count    
    add si,2
    add di,2
    mov bx,count
    cmp bx,total_bullet
    je fill_bullet3
    jmp nonempty_bullet2
    fill_bullet3:
    
    
    POP AX
    POP DX
    POP CX
    RET 
remove_bullet EndP


move_bullet Proc
    
    PUSH CX
    PUSH DX
    PUSH AX
    LEA si,bullet_x
    LEA di,bullet_y
    mov count,0
    nonempty_bullet:
    cmp word ptr[si],20          ;check if the bullet is on moving or not
    je empty2
    
    mov cx,[si]
    mov dx,[di]
    push si                      ;as we are changing si & di in checking bullet state so storing this si & di for future use
    push di
    call check_bullet            ;check if the bullet crossed the limit line or shooted any balloon
    pop di
    pop si
    cmp cx,20                    ;the bullet is more :(  
    je saveonly                 ; so only saved the changed value as it has been removed earlier
    
    mov dx,[di]                 
    MOV AL, 0
    CALL display_bullet         ;remove the bullet from previous position
   
    ADD CX, 5                   ;shift the x co-ordi to right side
    MOV AL, 3
    CALL display_bullet         ;draw the bullet in new position
    
    saveonly:
    MOV [si],CX                 ;save only changed x co-ordi as y will be reset when it is shooted by the gun
    
    empty2:
    inc count    
    add si,2
    add di,2
    mov bx,count
    cmp bx,total_bullet
    je fill_bullet1
    jmp nonempty_bullet         ;check for every bullet
    fill_bullet1:
    
    POP AX
    POP DX
    POP CX
    RET 
move_bullet EndP

    
MAIN PROC
    MOV AX, @data
    MOV DS, AX
    

    
    
; set up timer interrupt vector
    MOV new_timer_vec, offset timer_tick
    MOV new_timer_vec+2, CS
    MOV AL, 1CH; interrupt type
    LEA DI, old_timer_vec
    LEA SI, new_timer_vec
    CALL setup_int

;set up keyboard interrupt vector
    MOV NEW_KEY_VEC,OFFSET KEYBOARD_INT ;offset
    MOV NEW_KEY_VEC+2,CS        ;segment
    MOV AL,9H       ;interrupt number
    LEA DI,OLD_KEY_VEC
    LEA SI,NEW_KEY_VEC
    CALL    SETUP_INT
Setdisplay:
    CALL set_display_mode     ; set graphics display mode & draw border

START_KEY:
    CMP KEY_FLAG,1          ;check key flag
    JNE START_KEY          ;not set, go check timer flag
    MOV KEY_FLAG,0          ;flag set, clear it and check
    
KEY_1:   
    CMP SCAN_CODE,P_KEY     ;check for continue key
    JNE KEY_2               ;no, check for new game key    
    JMP FILE_READ           ;Read the previously save game

KEY_2:   
    CMP SCAN_CODE,N_KEY    ;check for new game key  
    JNE START_KEY          ;no, check for key press
    MOV GAME_TIMER,0       ;start the new game
    JMP STARTGAME  
    
FILE_READ:
    LEA DX, FILE  ;GET ADDR OF FILE NAME 
    MOV AL,0
    CALL OPEN     ; OPEN FILE
    JC OPEN_ERROR ; EXIT IF ERROR
    MOV HANDLE,AX ; SAVE HANDLE 

    MOV DX,0 
READ_KEY:                   ;restore the data
    MOV BX,HANDLE 
    ;GUN
    LEA DX,GUN_TOP 
    MOV CX,2
    CALL READ 
    
    LEA DX,GUN_BOTTOM 
    MOV CX,2
    CALL READ 
    ;bullet
    LEA DX,bullet_x 
    MOV CX,TOTAL_BULLET2
    CALL READ 
    
    LEA DX,bullet_y
    MOV CX,TOTAL_BULLET2
    CALL READ
    ;balloon
    LEA DX,balloon_x 
    MOV CX,TOTAL_balloon2
    CALL READ 
    
    LEA DX,balloon_y
    MOV CX,TOTAL_balloon2
    CALL READ
    ;score
    LEA DX,Score1 
    MOV CX,2
    CALL READ

    LEA DX,Score2 
    MOV CX,2
    CALL READ
    ;Game timer
    LEA DX,game_timer 
    MOV CX,2
    CALL READ
    
    ;MOV AH,9
    ;int 21h
    CALL CLOSE
    JMP STARTGAME
    ;JMP EXITGAME
OPEN_ERROR:
    LEA DX, OPENERR
    MOV AH,9
    INT 21H
    JMP EXITGAME
    
WRITE_ERROR:
    LEA DX, WRITERR
    MOV AH,9
    INT 21H
    
    JMP EXITGAME
    
STARTGAME:

    mov ah,2                ;removes the press key type lines for starting the game
    mov bh,0
    mov dx,080Ah
    int 10h
    
    MOV AH,9
    LEA DX,REMOVE
    INT 21H
    
    MOV AH,2
    MOV BH,0
    MOV DX,0C0AH
    INT 10H
    
    MOV AH,9
    LEA DX,REMOVE
    INT 21H
    
    MOV AH,2
    MOV BH,0
    MOV DX,0E0AH
    INT 10H
    
    MOV AH,9
    LEA DX,REMOVE
    INT 21H
    
    MOV AH,2
    MOV BH,0
    MOV DX,0F0AH
    INT 10H
    
    MOV AH,9
    LEA DX,REMOVE
    INT 21H
    
    MOV AH,2
    MOV BH,0
    MOV DX,110AH
    INT 10H
    
    MOV AH,9
    LEA DX,REMOVE
    INT 21H
    
     MOV AH,2
    MOV BH,0
    MOV DX,0000H
    INT 10H
    
    MOV AH,9
    LEA DX,SHOW_SCORE           ;show the score label
    INT 21H
    
    MOV AH,2
    MOV DL,SCORE2               ;show the tenth digit
    ADD DL,'0'
    INT 21H
    MOV DL,SCORE1               ;show the unit digit
    ADD DL,'0'
    INT 21H
    
    
    MOV AL,2        
    CALL    DRAW_GUN        ;draw the gun
    JMP TEST_KEY
    
START_KEY_RENEW1:           ;jump to upper level 
    JMP Setdisplay

TEST_KEY:
    CMP KEY_FLAG,1          ;check key flag
    JNE TEST_TIMER          ;not set, go check timer flag
    MOV KEY_FLAG,0          ;flag set, clear it and check
    
TK_1:   
    CMP SCAN_CODE,UP_ARROW  ;up arrow?
    JNE TK_2                ;no, check down arrow
    MOV AX,-2               ;yes, move up 2 pixels
    CALL MOVE_GUN    
    JMP TEST_TIMER          ;go check timer flag

TK_2:   
    CMP SCAN_CODE,DOWN_ARROW    ;up arrow?
    JNE TK_3                
    MOV AX,3                    ;yes, move down 3 pixels
    CALL MOVE_GUN    
    JMP TEST_TIMER              ;go check timer flag
START_KEY_RENEW:                ;jump to upper level
    JMP START_KEY_RENEW1
TK_3:   
    CMP SCAN_CODE,ESC_KEY       ;save key?
    JNE TK_4                   
    JMP SAVEGAME               ;go save game
TK_4: 
    CMP SCAN_CODE,RIGHT_ARROW  ;shoot bullet key?
    JNE TEST_TIMER
    LEA si,bullet_x
    LEA di,bullet_y
    mov cx,0
empty_bullet:
    mov ax,[si]
    cmp ax,20                   ;shoot the 1st empty bullet
    jne empty1
    mov dx,GUN_top              ;set bullet in GUN
    add dx,8
    mov [si],25
    mov [di],dx
    mov cx,25
    mov al,3
    call display_bullet         ;draw the new shooted bullet
    jmp fill_bullet
    empty1:
    inc cx
    add si,2
    add di,2
    cmp cx,total_bullet
    je fill_bullet              ;1st bullet shooted now you should break
    jmp empty_bullet            ;go check others
    fill_bullet:            
  
TEST_TIMER:
    CMP TIMER_FLAG,1            ;flag set?
    JNE TEST_KEY                ;no, check key flag
    MOV TIMER_FLAG,0            ;yes, clear it
    mov bx,game_timer           
    cmp bx,game_time            ;check the ending game time
    jl timercheck
    MOV AL,0        
    CALL DRAW_GUN
    call remove_bullet
    call remove_balloon
    RESTART_KEY:                    ;dislays the score and wait for restart game key press
    
    mov ah,2
    mov bh,0
    mov dx,080Ah
    int 10h
    
    MOV AH,9
    LEA DX,GAME_OVER
    INT 21H
    
    mov ah,2
    mov bh,0
    mov dx,0A0Ah
    int 10h
    
    MOV AH,9
    LEA DX,YOUR_SCORE
    INT 21H
    
    MOV AH,2
    MOV DL,SCORE2
    ADD DL,'0'
    INT 21H
    MOV DL,SCORE1
    ADD DL,'0'
    INT 21H
    
    
    mov ah,2
    mov bh,0
    mov dx,0C0Ah
    int 10h
    
    MOV AH,9
    LEA DX,AGAIN_RESTART
    INT 21H
    
    CMP KEY_FLAG,1          ;check key flag
    JNE RESTART_KEY         ;not set, go check timer flag
    MOV KEY_FLAG,0          ;flag set, clear it and check
    ;again restart
   
    
KEY_R:   
    CMP SCAN_CODE,R_KEY     ;check for restart key press
    JNE RESTART_KEY         
    MOV game_timer,0        
    JMP START_KEY_RENEW     ;go to the restart menu
    timercheck:             ;checks timer for new balloon move
    mov bx,timer
    cmp bx,interval
    jl fill_balloon
    mov bx,0
    mov timer,bx
    LEA si,balloon_x
    LEA di,balloon_y
    mov cx,0
    empty_balloon: 
    cmp [di],157             ;checks if the balloon is not moving yet
    jne empty3
    mov cx,[si]             
    mov bx,vel_y             ;move balloon upward
    sub [di],bx                 
    mov dx,[di]             
    mov al,3
    call display_balloon     ;draw the new balloon
    jmp fill_balloon         ;done. breaks the loop
    empty3:
    inc cx
    add si,2
    add di,2
    cmp cx,total_balloon
    je fill_balloon
    jmp empty_balloon
    fill_balloon:
    CALL MOVE_bullet        ;move bullets to new position
    CALL MOVE_balloon       ;move balloons to new position
    JMP TEST_KEY
SAVEGAME:                   ;save the current game state
    LEA DX, FILE            ;GET ADDR OF FILE NAME
    MOV AL,1
    CALL OPEN               ; OPEN FILE
    JC OPEN_ERROR1          ; EXIT IF ERROR
    MOV HANDLE,AX           ; SAVE HANDLE 
    
    MOV BX,HANDLE
    ;GUN
    MOV CX,2
    LEA DX,GUN_TOP
    CALL WRITE
    JC WRITE_ERROR1
      
    MOV CX,2
    LEA DX,GUN_BOTTOM
    CALL WRITE
    JC WRITE_ERROR1  
    ;bullet
    MOV CX,TOTAL_BULLET2
    LEA DX,bullet_x
    CALL WRITE
    JC WRITE_ERROR1
      
    MOV CX,TOTAL_BULLET2
    LEA DX,bullet_y
    CALL WRITE
    JC WRITE_ERROR1  
    ;balloon
    MOV CX,TOTAL_balloon2
    LEA DX,balloon_x
    CALL WRITE
    JC WRITE_ERROR1
      
    MOV CX,TOTAL_balloon2
    LEA DX,balloon_y
    CALL WRITE
    JC WRITE_ERROR1 
    ;Score
    MOV CX,2
    LEA DX,Score1
    CALL WRITE
    JC WRITE_ERROR1
    
    MOV CX,2
    LEA DX,Score2
    CALL WRITE
    JC WRITE_ERROR1
    ;Game timer
    MOV CX,2
    LEA DX,game_timer
    CALL WRITE
    JC WRITE_ERROR1
    ;close file
    CALL CLOSE
    JMP EXITGAME 
    OPEN_ERROR1:
    LEA DX, OPENERR
    MOV AH,9
    INT 21H
    JMP EXITGAME
    
    WRITE_ERROR1:
    LEA DX, WRITERR
    MOV AH,9
    INT 21H
    
    ;JMP EXITGAME    
DONE:
    LEA DI,NEW_TIMER_VEC
    LEA SI,OLD_TIMER_VEC
    MOV AL,1CH
    CALL SETUP_INT

    LEA DI,NEW_KEY_VEC
    LEA SI,OLD_KEY_VEC
    MOV AL,9H
    CALL SETUP_INT


    MOV AH,0
    INT 16H

    MOV AH,0
    MOV AL,3
    INT 10H

EXITGAME:
    MOV AH,4CH
    INT 21H
MAIN    ENDP

OPEN PROC NEAR 
    ;OPENS FILE
    ;INPUT DS:DX FILENAME, AL ACCESS CODE
    ;OUTPUT IF SUCCESSFUL AX HANDLE
    ;IF UNSUCCESSFUL CF =1 , AX = ERROR CODE

    MOV AH,3DH
    
    INT 21H
    RET
    OPEN ENDP
  
 WRITE PROC NEAR
    ;WRITES A FILE
    ;INPUT BX = HANDLE
    ;CX = BYTES TO WRITE
    ;DS:DX = DATA ADDRESS
    ;OUTPUT: AX = BYTES WRITTEN
    ;IF UNSUCCESSFUL CF =1, AX = ERROR CODE
    MOV AH,40H
    INT 21H
    RET
    WRITE ENDP 
READ PROC NEAR
    ;READS A FILE SECTOR
    ;INPUT: BX FILE HANDLE
    ;CX BYTES TO READ
    ;DS:DX BUFFER
    ;OUTPUT: IF SUCCESSFUL, SECTOR IN BUFFER
    ;AX NUMBER OF BYTED READ
    ;IF UNSUCCESSFUL CF =1    
    ;PUSH CX
    MOV AH,3FH
    ;MOV CX,512
    INT 21H
    ;POP CX
    RET
    READ ENDP 
  
CLOSE PROC NEAR
    ;CLOSES A FILE
    ;INPUT BX = HANDLE
    ;OUTPUT CF =1; ERROR CODE IN AX
    MOV AH,3EH
    INT 21H
    RET
    CLOSE ENDP
    
END MAIN
